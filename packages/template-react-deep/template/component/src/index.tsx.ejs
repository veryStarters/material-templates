import React from 'react';
import { ConfigProvider, Button } from '@ali/deep';
import PropTypes from 'vision-types';
import BaseField, { BEHAVIOR, formUtils } from '@ali/deep-form-helper';
import zhCN from './locale/zh-cn';

const {
  noop,
  passWhenExplicit,
} = formUtils;

class Deep<%= className %> extends BaseField {
  static displayName = '<%= className %>';

  // for low-code
  static propTypes = {
    ...BaseField.propTypes,
    deepPrefix: PropTypes.string,
    device: PropTypes.string,
    locale: PropTypes.object,
  };

  static defaultProps = {
    ...BaseField.defaultProps,
    deepPrefix: 'deep-',
    device: 'desktop',
    locale: zhCN,
  };

  // 必须实现，加入具体表单域的样式或其它属性
  getProps() {
    const { deepPrefix } = this.props
    return {
      ...this.props,
      fieldClassName: `${deepPrefix}<%= kebabCaseName %>`,
    };
  }

  // 可选实现，如果输出给开发者的数据格式和 Control 底层数据格式不一致则可以覆盖实现
  // formatValueOut(value, props) { return value; }

  // 可选实现，如果Control 底层需要的数据输入格式和开发者给的数据格式不一致则可以覆盖实现
  // formatValueIn(value, props) { return value; }

  // 可选实现，如果向上抛出的 onChange 事件的参数除了 value 还有其它数据时可以覆盖实现
  /*
  onChange: (value, evt) => {
    const formattedValue = this.formatValueOut(value, this.props);
    this.setValueOnChange(formattedValue);
    this.handleChange({
      value: formattedValue,
      actionType: 'change',
    }, evt);
  },
  */

  // 必须实现，具体表单域控件的渲染方法
  renderControl(fieldProps = {}) {
    const { behavior } = this.state;

    const {
      myProp,
      ...rest
    } = this.props;

    const xxxxProps = {
      ...rest,
      ...fieldProps, // 必须混入 fieldProps
      readOnly: behavior === BEHAVIOR.READONLY, // 如果支持 readOnly 属性
      myProp
    };
    // 请将`<%= className.replace('Field', '') %>FormItem`替换为待封装表单控件，同时请注意该组件是否遵循value/onChange规范
    return <<%= className.replace('Field', '') %>FormItem />;
  }
}

export default ConfigProvider.config(Deep<%= className %>, {});
